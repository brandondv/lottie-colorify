(function(g,t){typeof exports=="object"&&typeof module<"u"?t(exports):typeof define=="function"&&define.amd?define(["exports"],t):(g=typeof globalThis<"u"?globalThis:g||self,t(g.index={}))})(this,function(g){"use strict";const t=s=>{if(typeof s=="string"&&s.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i)){const o=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(s);if(!o)throw new Error("Color can be only hex or rgb array (ex. [10,20,30])");return[Math.round(parseInt(o[1],16)/255*1e3)/1e3,Math.round(parseInt(o[2],16)/255*1e3)/1e3,Math.round(parseInt(o[3],16)/255*1e3)/1e3,1]}else{if(typeof s=="object"&&s.length===3&&s.every(o=>o>=0&&o<=255))return[Math.round(s[0]/255*1e3)/1e3,Math.round(s[1]/255*1e3)/1e3,Math.round(s[2]/255*1e3)/1e3,1];if(typeof s=="object"&&s.length===4&&s.every(o=>o>=0&&o<=255))return[Math.round(s[0]/255*1e3)/1e3,Math.round(s[1]/255*1e3)/1e3,Math.round(s[2]/255*1e3)/1e3,s[3]];throw s?new Error("Color can be only hex or rgb(a) array (ex. [10,20,30,1])"):new Error("Color not defined")}},e=s=>{const o=Math.round(s[0]*255).toString(16).padStart(2,"0"),k=Math.round(s[1]*255).toString(16).padStart(2,"0"),a=Math.round(s[2]*255).toString(16).padStart(2,"0");return`#${o}${k}${a}`},m=s=>[Math.round(s[0]*255),Math.round(s[1]*255),Math.round(s[2]*255)],p=s=>[Math.round(s[0]*255),Math.round(s[1]*255),Math.round(s[2]*255),s[3]],S=s=>{const o=[];function k(a){if(a.g&&a.g.k&&a.g.k.k&&Array.isArray(a.g.k.k)&&a.g.k.k.length%4===0){Array.isArray(a.g.k.k)&&typeof a.g.k.k[0]!="number"&&k(a.g.k.k);const u=[...a.g.k.k];for(;u.length;){const d=[...u.splice(1,3),u.shift()];o.push(p(d))}}else if(a.s&&Array.isArray(a.s)&&a.s.length===4)o.push(p(a.s));else if(a.c&&a.c.k)Array.isArray(a.c.k)&&typeof a.c.k[0]!="number"?k(a.c.k):o.push(m(a.c.k));else for(const u in a)typeof a[u]=="object"&&k(a[u]);return o}return k(s),o},w=s=>{const k=S(s).map(u=>JSON.stringify(u)),a=new Set(k);return Array.from(a,u=>JSON.parse(u))},T=(s,o,k=!0)=>{let a=0;function u(d,f){f&&f.s&&Array.isArray(f.s)&&f.s.length===4?(d[a]&&(f.s=[...d[a]]),a++):f&&f.c&&f.c.k&&(Array.isArray(f.c.k)&&typeof f.c.k[0]!="number"?u(d,f.c.k):(d[a]&&(f.c.k=d[a]),a++));for(const h in f)typeof f[h]=="object"&&u(d,f[h]);return f}return u(s,k?structuredClone(o):o)},v=(s=[],o,k=!0)=>{const a=[];return s.forEach(u=>{a.push(t(u))}),T(a,k?structuredClone(o):o)},C=(s,o,k=!0)=>{const a=t(s);if(!a)throw new Error("Proper colors must be used for target");function u(d,f){if(f&&f.s&&Array.isArray(f.s)&&f.s.length===4)f.s=[...d];else if(f&&f.c&&f.c.k)Array.isArray(f.c.k)&&typeof f.c.k[0]!="number"?u(d,f.c.k):f.c.k=d;else for(const h in f)typeof f[h]=="object"&&u(d,f[h]);return f}return u(a,k?structuredClone(o):o)},l=s=>Math.round(s*1e3)/1e3,A=(s,o,k,a=!0)=>{const u=t(s),d=t(o);if(!u||!d)throw new Error("Proper colors must be used for both source and target");function f(h,M,r){if(r&&r.s&&Array.isArray(r.s)&&r.s.length===4)h[0]===r.s[0]&&h[1]===r.s[1]&&h[2]===r.s[2]&&(r.s=[...M]);else if(r&&r.c&&r.c.k)Array.isArray(r.c.k)&&typeof r.c.k[0]!="number"?f(h,M,r.c.k):Math.abs(h[0]-l(r.c.k[0]))<.003&&Math.abs(h[1]-l(r.c.k[1]))<.003&&Math.abs(h[2]-l(r.c.k[2]))<.003&&(r.c.k=M);else if(r.g&&r.g.k&&r.g.k.k&&r.g.k.k.length%4===0)for(let y=0;y<r.g.k.k.length;y+=4)Math.abs(l(h[0])-l(r.g.k.k[y+1]))<.003&&Math.abs(l(h[1])-l(r.g.k.k[y+2]))<.003&&Math.abs(l(h[2])-l(r.g.k.k[y+3]))<.003&&(r.g.k.k[y+1]=M[0],r.g.k.k[y+2]=M[1],r.g.k.k[y+3]=M[2],r.g.k.k[y+4]=M[3]);else for(const y in r)typeof r[y]=="object"&&f(h,M,r[y]);return r}return f(u,d,a?structuredClone(k):k)},E=(s,o)=>s.reduce((k,[a,u])=>A(a,u,k),o),R=(s,o,k)=>{let a={...k};return s.forEach((u,d)=>{const f=o[d%o.length];a=A(u,f,a)}),a};g.colorify=v,g.convertColorToLottieColor=t,g.convertLottieColorToHex=e,g.convertLottieColorToRgb=m,g.convertLottieColorToRgba=p,g.flatten=C,g.getColors=S,g.getUniqueColors=w,g.modifyColors=T,g.replaceColor=A,g.replaceColors=E,g.replaceColorsLoop=R,Object.defineProperty(g,Symbol.toStringTag,{value:"Module"})});
